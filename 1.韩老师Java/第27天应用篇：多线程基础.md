## 线程

### 1.线程介绍

#### 程序

某种语言编写的一组指令的集合。

#### 进程

进程是指运行中的程序。

1. 当启动了一个进程，操作系统就会为该进程分配内存空间。
2. 进程有自身的，产生、存在和消亡的过程。

#### 线程

进程可创建多个线程，线程是进程的一个实体。如：一个迅雷(进程) 有三个下载任务(线程)。

##### 单线程

同一个时刻，只允许执行一个线程。

##### 多线程

同一个时刻，可以执行多个线程。

##### 其他相关概念

<img src="C:/Users/10275/AppData/Roaming/Typora/typora-user-images/image-20220921164004357.png" alt="image-20220921164004357" style="zoom:80%;" />

- 并发：类似人脑工作，不断切换地进行工作。

- 并发和并行 可以同时存在。



### 2.线程创建/使用

#### 创建/使用 线程的两种方式（java中）

1. 继承 Thread 类 ，重写 run 方法。
2. 实现 Runnable 接口，重写 run 方法。

#### 1) Thread类方式

##### 继承图

<img src="https://raw.githubusercontent.com/LifeSum12/typora-image/main/img/202209211641561.png" alt="image-20220921164144461" style="zoom: 67%;" />

案例：

```java
//主函数
public class main {

    public static void main(String[] args) {
        Cat cat = new Cat();
        cat.start();//启动线程，start方法会调用run方法。
       
        for (int i = 0; i < 50; i++) {
            System.out.println("main执行");
        }
    }

}
/*
1.当一个类继承Tread类后，该类就可以当作线程使用
2.要重写run方法，写上自己需要让线程完成的业务代码。(run方法不是Thread的，是Thread实现的Runnable接口)
*/
class Cat extends Thread {
    @Override
	public void run() {
        while (true) {
            try{
                Thread.sleep(500); //让线程休眠500毫秒
            } catch(InterruptedException e) {
                e.printStackTrace();
            }
 	 		System.out.println("呼叫");
        }
    }
}
```

##### 多线程机制

**当主线程启动一个子线程时，主线程不会阻塞，会继续执行。主线程和子线程是一起执行。**

如上图：当线程main中，创建了一个Cat线程。启动Cat线程时，Cat线程和主线程任务会一起执行 (并发或并行) 。并且只有当两个线程全都结束后，该进程才会结束。

##### Start方法

​	执行 Start0，该方法是native方法。它是真正实现多线程效果的方法。 (run方法在Start0里被调用，该方法由底层jvm实现无法看到)

​	 Start方法调用Start0方法后，该线程不一定立马会执行，只是将线程变成了可执行状态。具体什么时候执行，取决于CPU，有CPU统一调度。

- native方法：本地方法，是最底层的(由c/c++实现)。由JVM调用的。

<img src="https://raw.githubusercontent.com/LifeSum12/typora-image/main/img/202209211645076.png" alt="image-20220921164526948" style="zoom:80%;" />



#### 2) Runable接口方式

```java
/*
1. 类实现Runable接口，重写run方法。【此时该类，不能直接调用start方法。因为Runable接口中只有一个run抽象方法。】
2. 利用Thread类的有参构造方法，传入该类（Runable的实现类）。
3. 让thread类代替该类，启动线程。
- 这种设计模式称为代理模式Proxy -
*/

public class main {
    public static void main(String[] args) {
        T1 t1 = new T1();
        Thread thread = new Thread(t1);
        thread.start();
    }
}


class T1 implements Runnable {
    int count = 0;
    @Override
    public void run() {
        while (count < 10) {
            count++;
            System.out.println(count+"  Hello, world!");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

##### 优点

​	本质上，实现Runable接口来创建线程 和 通过继承Thread类方法 没有区别。因为都是调用Tread的start方法。

- 避免了单继承的限制。（由于java单继承限制，可能某些类需要继承自己本身父类，无法再继承Thread）
- 实现Runable接口方式，适合多个线程共享一个资源。（继承方式需要设置静态属性。实现接口方式，不需要设置，因为只需要创建一个对象。）



#### 线程终止

1. 当任务完成后，自动退出。
2. 通知方式：通过变量来控制 run 方法退出，从而提前停止线程。

##### 通知线程退出

​	如：类中设置一个布尔值loop，但true时一直执行线程。主函数通过set方法把它改为false后，通知它-终止它的运行。



### 3.线程方法

##### Thread类 常用方法

第一组：

<img src="C:/Users/10275/AppData/Roaming/Typora/typora-user-images/image-20220921164707967.png" alt="image-20220921164707967" style="zoom: 80%;" />

- setName方法使用：	Thread.currentThread().getName()
  - Thread不能直接调用getName方法。
  - currentThread()是一个本地方法，返回一个线程。
- 调用Start方法才会启动线程 (并且内部start0调用run方法)。
- 调用run方法不启动线程，仅仅是调用方法。
- 线程优先级范围，类中有三个常量值定义。优先级数值必须再min-max之间(即：1-10)

- interrupt中断线程。并不是真正结束线程，是用于中断正在休眠的线程。(唤醒正在休眠的线程)

第二组：

<img src="C:/Users/10275/AppData/Roaming/Typora/typora-user-images/image-20220921164932417.png" alt="image-20220921164932417" style="zoom:80%;" />

**yield方法：**

​	**线程的礼让(不一定成功)。**让出CPU，让其他线程执行，但礼让时间不确定，也不一定礼让成功。

（如：当cpu空闲资源很多时候，无需礼让，两个线程都能一起执行。而当空闲资源很紧缺时候，会优先执行被礼让的线程。）

**join方法：**

​	**线程的插队(一定成功)。**插队的线程先执行完，才会执行该线程。

（如：主线程Thread1，执行语句Thread2.join后，会先完全执行完毕Thread2线程后，才会再往下执行完主线程Thread1）



**用户线程和守护线程**

<img src="https://raw.githubusercontent.com/LifeSum12/typora-image/main/img/202209211650476.png" alt="image-20220921165053377" style="zoom:80%;" />

​	若把子线程设置为守护线程，当主线程结束时，子线程也会立即结束 [因为它是为主线程(用户线程)服务的] 。

实例操作：

![image-20220921165325245](https://raw.githubusercontent.com/LifeSum12/typora-image/main/img/202209211653352.png)



### 4.线程生命周期

#### 官方jdk分类6种状态： 

1. New	尚未启动
2. Runnable  执行中
3. Blocked   被阻塞
4. Waiting    等待另一个进程特定动作
5. Timed_Waiting  等待另一个进程达到指定时间
6. Terminated  退出

**JDK 中用 Thread.State 枚举表示了线程的几种状态**：

<img src="https://raw.githubusercontent.com/LifeSum12/typora-image/main/img/202209211653552.png" alt="image-20220921165355455"  />



**线程状态转换图：**

<img src="https://raw.githubusercontent.com/LifeSum12/typora-image/main/img/202209211656677.png" alt="image-20220921165658565" style="zoom:80%;" />



#### 其中Runnable状态可细分为了： ready状态 和  Running状态。

```java
public class ThreadState_ {
	public static void main(String[] args) throws InterruptedException { 
        T t = new T();
		System.out.println(t.getName() + " 状态 " + t.getState());
		t.start();
		while (Thread.State.TERMINATED != t.getState()) {
			System.out.println(t.getName() + " 状态 " + t.getState());
			Thread.sleep(500);
		}
		System.out.println(t.getName() + " 状态 " + t.getState());
	} 
}

class T extends Thread {
	@Override
	public void run() {
		while (true) {
            for (int i = 0; i < 10; i++) {
                    System.out.println("hi " + i);
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    } 
            }
		break;
		} 
    } 
}
```

**可用 Thread.getState() 方法来获取当前线程状态。**



### 解决办法

### 5. Synchronized（线程同步机制）

目的：解决多个线程同时售卖票的问题，防止出现负票bug。

#### 基本概念

<img src="C:/Users/10275/AppData/Roaming/Typora/typora-user-images/image-20220921170204264.png" alt="image-20220921170204264" style="zoom:80%;" />



#### 具体方法

![image-20220921170310784](https://raw.githubusercontent.com/LifeSum12/typora-image/main/img/202209211703962.png)

- 同步后的 代码块/方法 ，只允许同时一个线程执行。
- 同步原理：使用了锁



### 6. 互斥锁

**介绍：**

<img src="https://raw.githubusercontent.com/LifeSum12/typora-image/main/img/202209211704257.png" alt="image-20220921170453083"  />



如：（代码块，要赋给实例化的一个对象。一般使用该类对象this）

```java
synchronized (this) {
    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    Money -= 1000;
    System.out.println(Thread.currentThread().getName() + "取钱。卡里还剩余" + Money);
    if (Money <= 0) loop = false;
}
```

**注意事项：**

<img src="https://raw.githubusercontent.com/LifeSum12/typora-image/main/img/202209211706822.png" alt="image-20220921170643707" style="zoom: 80%;" />

### 7. 死锁

**介绍：**

![image-20220921170718569](https://raw.githubusercontent.com/LifeSum12/typora-image/main/img/202209211707632.png)



如：当两个线程 A,B 同时启动，一个flag=true ，另一个flag = false；

**案例：**

<img src="https://raw.githubusercontent.com/LifeSum12/typora-image/main/img/202209211708244.png" alt="image-20220921170807192" style="zoom: 80%;" />

发生死锁，A和B线程都被阻塞，程序无法结束。



### 8. 释放锁

**介绍：**

下面操作会释放锁。

![image-20220921170835738](https://raw.githubusercontent.com/LifeSum12/typora-image/main/img/202209211708941.png)

下面操作不会释放锁。

<img src="C:\Users\10275\AppData\Roaming\Typora\typora-user-images\image-20211206172810488.png" alt="image-20211206172810488"  />

## 事务

1.事务管理

2.savepoint

3.rollback

4.commit

5.隔离级别 

6.ACID

#### 定义：

​	事物用于保证数据的一致性，它**由一组相关的*DML***(Data Manipulation Language  数据操纵*语言*)**语句组成**。改dml语句要么全部成功，要么全部失败。

如：银行转账，A转B一千元。步骤一是A账户扣1000元，二是B账号加1000元。若步骤二成功了，一未成功。为防止此类情况，引出了事务，把dml看成一个整体。

#### 特性：

简称acid

1. 原子性（Atomicity）

2. 一致性（Consistency）

3. 隔离性（Isolation）
4. 持久性（Durability）

<img src="https://raw.githubusercontent.com/LifeSum12/typora-image/main/img/202207081432412.png" alt="image-20220708143232224" style="zoom:80%;" />



#### 事务的操作：

<img src="https://raw.githubusercontent.com/LifeSum12/typora-image/main/img/202303151928458.png" alt="image-20230315192313111" style="zoom:80%;" />

操作示意图：

![image-20230315192835378](https://raw.githubusercontent.com/LifeSum12/typora-image/main/img/202303151928907.png)

```mysql
#开始事务
START TRANSACTION;

#设置保存点a
SAVEPOINT a;
INSERT INTO stu VALUES(4,'ning'); -- 操作1
#设置保存点b
SAVEPOINT b;
INSERT INTO stu VALUES(5,'wei'); -- 操作2
#回滚到b。
ROLLBACK TO b;	-- 即5号wei数据没有插入

ROLLBACK; -- 全部回滚
COMMIT; -- 提交
```

- 未启动事务，一组操作会直接生效，系统自动帮commit，无法回滚。
- 启动了事务，一组操作也会先生效。但只要还未执行提交commit，就可以进行回滚操作，会到任意的保存到。【但注意，如果一直未提交超时，系统会自动全部回滚】

- 当提交事务commit后，会结束事务：删除保存点，释放锁，数据生效。且其他会话（连接）将可以查看到事务变化后的新数据。（所有数据正式生效）



#### **使用细节：**

![image-20220308175535714](C:\Users\10275\AppData\Roaming\Typora\typora-user-images\image-20220308175535714.png)

**mysql中set autocommit=0与start transaction区别**

1. 当autocommit 为 0 时，不管有没有START TRANSACTION。只有当commit数据才会生效，ROLLBACK后就会回滚。

2. 不管autocommit 是1还是0 。START TRANSACTION 后，只有当commit数据才会生效，ROLLBACK后就会回滚。

3. 如果autocommit 为1 ，并且没有START TRANSACTION。调用ROLLBACK是没有用的。即便设置了SAVEPOINT。



## 事务隔离级别

###  介绍

![image-20220708143435912](https://raw.githubusercontent.com/LifeSum12/typora-image/main/img/202207081434009.png)

#### 三种问题介绍

![image-20220708143452027](https://raw.githubusercontent.com/LifeSum12/typora-image/main/img/202207081434134.png)

不可重复读 和 幻读 区别：

​	不可重复读指单条数据会变化，有线程修改这条数据，每次读结果不一样。 

​	幻读指查询的结果集数量会变化，有线程插入新的数据，每次读取的数量不一样。



Mysql隔离级别定义了 事务与事务之间的隔离程度。

![mysql事务隔离级别_mysql事务的隔离级别_wandoubi的博客-CSDN博客](https://raw.githubusercontent.com/LifeSum12/typora-image/main/img/202304211301639.png)

​	**mysql默认的事务隔离级别是 可重复读(Repeated read)，一般情况下，没有特殊要求，没有必要修改。（几乎可以满足绝大部分项目要求）**

```mysql
#可开启多个mysql控制台，不同控制台可设置不同的隔离级别
#1.1 查看当前mysql的隔离级别（当前用户）
select @@tx_isolation;
#1.2 查看当前系统隔离级别(所有用户)
select @@global.tx_isolation;

#2.1 设置当前会话的隔离级别
#语法：set session transaction isolation level 隔离级别;
set session transaction isolation level read uncommitted;
#2.2 设置系统当前的隔离级别
#语法：set global transaction isolation level 隔离级别;
set global transaction isolation level read uncommitted;

```

当多个控制台在操作一个数据库时，一个控制台不同的级别隔离会出现的情况：

（顾名思义）

**读未提交：**只要别的控制台改变了数据，就可以读到。

**读已提交：**只能读取别的控制台提交后改变的数据，当别的控制台改变了数据但未提交，该控制台不会读取到。

**可重复读(默认)：**以上两种情况都不会出现。控制台读取数据时，mysql把读取到的数据加锁锁住，不允许其他控制台修改或删除。但无法避免其他控制台insert数据，因为仅仅锁住了刚刚读到的数据。

**可串行化：**加锁。意味着当其他控制台在操作某一张表时，若本控制台想要操作这张表会被锁住（即会等待，等到其他表commit后才可以操作）。若等待时间过长，会超时。

- 当可串行化的控制台在查询一张表数据时候，只要未commit结束事务，其他控制台都不能操作该表，所以不会出现幻读、不可重复读情况。
- 当其他控制台在一张表修改/添加数据时，可串行化的控制台不能查询该表，只有当其他控制台commit结束事务后，才可以查询到。所以也不会出现幻读、不可重复读情况。



### 实现机制

如何实现事务隔离级别呢？ 加锁。

不同角度下锁的划分：

![image-20220711203519162](https://raw.githubusercontent.com/LifeSum12/typora-image/main/img/202304191634438.png)

#### 悲观锁（数据库自带）

悲观锁是一种思想，顾名思义，就是很悲观，对数据被其他事务的修改持保守态度，会通过数据库自身的锁机制来实现，从而保证数据操作的排它性。

**1. 共享锁（S锁）**

数据加了共享锁，其他事务只能读到该数据，不能修改数据。

**2. 排他锁（X锁）**

数据加了排他锁，其他事务既不能读该数据，也不能修改数据。

#### 乐观锁（自定义）

乐观锁认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，也就是**不采用数据库自身的锁机制，而是通过程序来实现**。在程序上，我们可以采用 `版本号机制` 或者 `CAS机制` 实现。





### 传播机制

事务传播机制是指，包含多个事务的方法在相互调用时，事务是如何在这些方法间传播的。

## Spring 事务传播机制有哪些？

Spring 事务传播机制可使用 @Transactional(propagation=Propagation.REQUIRED) 来定义，Spring 事务传播机制的级别包含以下 7 种：

1. **Propagation.REQUIRED：默认的事务传播级别，它表示如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。**
2. Propagation.SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。
3. Propagation.MANDATORY：（mandatory：强制性）如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。
4. Propagation.REQUIRES_NEW：表示创建一个新的事务，如果当前存在事务，则把当前事务挂起。也就是说不管外部方法是否开启事务，Propagation.REQUIRES_NEW 修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。
5. Propagation.NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。
6. Propagation.NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。
7. Propagation.NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于 PROPAGATION_REQUIRED。

以上 7 种传播机制，可根据“是否支持当前事务”的维度分为以下 3 类：

![image-20230421130910240](https://raw.githubusercontent.com/LifeSum12/typora-image/main/img/202304211309316.png)

### 3. 找出数组中重复的数字

![image-20211212165924963](C:\Users\10275\AppData\Roaming\Typora\typora-user-images\image-20211212165924963.png)



#### 方法一：hash

​	使用 HashSet 集合（set集合不能有重复值），当插入失败时候，返回该值。[Hash表查找时间复杂度为O(1)]

**时间复杂度：O(n)	空间复杂度：O(n)**



#### 方法二：

利用题目给的 “所有数字都在0 ~ n-1 范围内”	

​	开辟新数组，坐标位置记录次数。如 count[i] 则记录i出现的次数。

**时间复杂度：O(n)	空间复杂度：O(n)**



#### 方法三：原地交换。

数组元素的 **索引** 和 **值** 是 **一对多** 的关系。

因此，可遍历数组并通过交换操作，使元素的 索引 与 值 一一对应（即 nums[i] = inums[i]=i ）。因而，就能通过索引映射对应的值，起到与字典等价的作用。

遍历中，第一次遇到数字 xx 时，将其交换至索引 xx 处；而当第二次遇到数字 xx 时，一定有 nums[x] = xnums[x]=x ，此时即可得到一组重复数字。[具体做法](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/solution/mian-shi-ti-03-shu-zu-zhong-zhong-fu-de-shu-zi-yua/)

**时间复杂度：O(n)	空间复杂度：O(1)**



### 4. 二维数组中的查找

在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。



**示例:**

现有矩阵 matrix 如下：

```
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
```

给定 target = `5`，返回 `true`。

给定 target = `20`，返回 `false`。

**限制：**

```
0 <= n <= 1000
0 <= m <= 1000
```



#### 方法一： 暴力

**时间复杂度：O(n^2)	空间复杂度：O(1)**



#### 方法二： 线性查找

利用题目信息(递增)，可以排除部分元素，减少时间复杂度。

​	从二维数组的右上角开始查找。如果当前元素等于目标值，则返回 true。如果当前元素大于目标值，则移到左边一列。如果当前元素小于目标值，则移到下边一行。[具体做法](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution/mian-shi-ti-04-er-wei-shu-zu-zhong-de-cha-zhao-b-3/)

**时间复杂度：O(n+m)	空间复杂度：O(1)**

注意：需要判数组为空指针，或者数组值为空的情况。（系统实例中含有）



### 5.替换空格

请实现一个函数，把字符串 s 中的每个空格替换成"%20"。

示例 1：

```j
输入：s = "We are happy."
输出："We%20are%20happy."
```


限制：

0 <= s 的长度 <= 10000



#### 方法一：

用Stringbuilded (比buffer更快)，来存储新的字符串。

```java
class Solution {
    public String replaceSpace(String s) {
        StringBuilder res = new StringBuilder();
        for(Character c : s.toCharArray())
        {
            if(c == ' ') res.append("%20");
            else res.append(c);
        }
        return res.toString();
    }
}
```

**时间复杂度：O(n)	空间复杂度：O(n)**



### 6. 从尾到头打印链表

输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。

示例 1：

输入：head = [1,3,2]
输出：[2,3,1]


限制：

0 <= 链表长度 <= 10000



#### 方法一：栈。

**时间复杂度：O(n)	空间复杂度：O(n)**

#### 方法二：递归。

使用ArrayList的add方法。

**时间复杂度：O(n)	空间复杂度：O(n)**



### 7.重建二叉树⭐⭐⭐

输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。

假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

![img](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)

```j
示例1:
Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]
```

```j
示例 2:
Input: preorder = [-1], inorder = [-1]
Output: [-1]
```


限制：

```
0 <= 节点个数 <= 5000
```





### 8.用两个栈实现队列

​	用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )



### 9.斐波那契数列

写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：

```
F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
```

斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。



#### 方法一：递归

超时。



#### 方法二：递推

**时间复杂度：O(n)	空间复杂度：O(n)**



#### 方法三：动态规划⭐⭐

优化空间复杂度。滚动数组来实现，开辟多三个（类似指针作用）的变量。

**时间复杂度：O(n)	空间复杂度：O(1)**



#### 方法四：矩阵快速幂⭐⭐

用矩阵快速幂的方法可以降低时间复杂度。

构建一个递推关系，把题目转换成计算矩阵的幂。

**时间复杂度：O(logn)	空间复杂度：O(1)**

[具体做法](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/solution/fei-bo-na-qi-shu-lie-by-leetcode-solutio-hbss/)
